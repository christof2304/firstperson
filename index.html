<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>3D Viewer - Google Photorealistic Tiles</title>
  
  <!-- Cesium JS 1.134 (Latest) -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.134/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.134/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    #cesiumContainer {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* Hamburger Menu Button */
    #menuToggle {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1001;
      width: 44px;
      height: 44px;
      background: rgba(48, 51, 54, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      color: white;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      -webkit-tap-highlight-color: transparent;
    }

    #menuToggle:hover {
      background: rgba(66, 133, 244, 0.9);
    }

    /* Control Panel */
    #panel {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1000;
      width: 320px;
      max-width: calc(100vw - 20px);
      height: 100%;
      max-height: 100vh;
      overflow-y: auto;
      background: rgba(38, 41, 44, 0.95);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 70px 15px 20px 15px;
      transform: translateX(-110%);
      transition: transform 0.3s ease;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
    }

    #panel.open {
      transform: translateX(0);
    }

    #panel h3 {
      color: #4285f4;
      font-size: 14px;
      margin: 20px 0 10px 0;
      padding-bottom: 5px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    #panel h3:first-child {
      margin-top: 0;
    }

    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 10px 0;
      color: #e0e0e0;
      font-size: 13px;
    }

    .control-row label {
      flex: 1;
    }

    .control-row input[type="range"] {
      width: 120px;
      accent-color: #4285f4;
    }

    .control-row input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: #4285f4;
    }

    .control-row select {
      padding: 5px 10px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: white;
      font-size: 12px;
    }

    .btn {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      background: linear-gradient(135deg, #4285f4, #34a853);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(66, 133, 244, 0.4);
    }

    .btn.danger {
      background: linear-gradient(135deg, #ea4335, #ff6b6b);
    }

    .btn.secondary {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* Close Button inside Panel */
    #panelClose {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 6px;
      color: white;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #panelClose:hover {
      background: rgba(234, 67, 53, 0.8);
    }

    /* Status Boxes */
    .status-box {
      position: absolute;
      z-index: 999;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(5px);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      color: white;
      pointer-events: none;
    }

    #fpsBox {
      bottom: 140px;
      right: 10px;
      text-align: right;
    }

    #fpsBox .fps-value {
      font-size: 28px;
      font-weight: bold;
    }

    #fpsBox .fps-value.good { color: #34a853; }
    #fpsBox .fps-value.medium { color: #fbbc04; }
    #fpsBox .fps-value.bad { color: #ea4335; }

    #fpsBox .vram-info {
      font-size: 11px;
      color: #aaa;
      margin-top: 4px;
    }

    #fpsBox .vram-value { color: #4fc3f7; }
    #fpsBox .vram-limit { color: #888; }

    #loadingBox {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      padding: 20px 30px;
    }

    #loadingBox .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-top-color: #4285f4;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #loadingBox .progress-bar {
      width: 200px;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      margin-top: 10px;
      overflow: hidden;
    }

    #loadingBox .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4285f4, #34a853);
      transition: width 0.3s ease;
    }

    #qualityBox {
      top: 10px;
      right: 320px;
      font-size: 11px;
      padding: 6px 10px;
    }

    #qualityBox .quality-label {
      color: #888;
    }

    #qualityBox .quality-value {
      color: #4fc3f7;
      font-weight: bold;
    }

    /* Mobile Quick Actions */
    #quickActions {
      position: absolute;
      bottom: 160px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 998;
      display: none;
      gap: 15px;
    }

    .quick-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .quick-btn:active {
      transform: scale(0.95);
    }

    .quick-btn.fps-btn { background: linear-gradient(135deg, #34a853, #4caf50); }
    .quick-btn.shadow-btn { background: linear-gradient(135deg, #ff9800, #f57c00); }
    .quick-btn.quality-btn { background: linear-gradient(135deg, #9c27b0, #7b1fa2); }

    .quick-btn.active {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }

    /* Mobile Styles */
    @media (max-width: 768px) {
      #quickActions {
        display: flex;
      }

      #panel {
        width: calc(100vw - 40px);
      }

      #qualityBox {
        top: 10px;
        right: 50px;
      }

      #fpsBox {
        bottom: 140px;
      }
    }

    /* First Person Crosshair */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 997;
      pointer-events: none;
      display: none;
    }

    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
    }

    #crosshair::before {
      width: 20px;
      height: 2px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    #crosshair::after {
      width: 2px;
      height: 20px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    /* Mode Indicator */
    #modeIndicator {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 998;
      background: rgba(66, 133, 244, 0.9);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      color: white;
      display: none;
    }

    /* Cesium viewer bottom credit styling */
    .cesium-viewer-bottom {
      background: transparent !important;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <!-- Hamburger Menu Toggle -->
  <button id="menuToggle" aria-label="Men√º √∂ffnen">‚ò∞</button>

  <!-- Control Panel -->
  <div id="panel">
    <button id="panelClose" aria-label="Men√º schlie√üen">‚úï</button>

    <h3>üéÆ Steuerung</h3>
    <button class="btn" id="btnFirstPerson">üéÆ First-Person Modus (C)</button>
    <div id="gamepadStatus" style="padding:8px;border-radius:6px;background:rgba(251,188,4,0.2);margin:10px 0;font-size:12px;">
      <span style="color:#fbbc04;">üéÆ Kein Controller</span>
    </div>
    <div class="control-row">
      <label>Geschwindigkeit</label>
      <input type="range" id="moveSpeed" min="1" max="50" value="8">
    </div>
    <div class="control-row">
      <label>Maus-Sensitivit√§t</label>
      <input type="range" id="mouseSensitivity" min="1" max="100" value="50">
    </div>

    <h3>üåÖ Beleuchtung & Tageszeit</h3>
    <div class="control-row">
      <label>Dynamische Beleuchtung</label>
      <input type="checkbox" id="chkLighting">
    </div>
    <div class="control-row">
      <label>Beleuchtungsmodus</label>
      <select id="ambientMode">
        <option value="realistic">Realistisch</option>
        <option value="soft">Weich</option>
        <option value="balanced">Ausgewogen</option>
        <option value="bright">Hell (kein Tag/Nacht)</option>
      </select>
    </div>
    <div class="control-row">
      <label>Tageszeit (UTC)</label>
      <input type="range" id="timeOfDay" min="0" max="24" value="12" step="0.5">
    </div>
    <div class="control-row">
      <label>Zeit-Preset</label>
      <select id="timePreset">
        <option value="">-- W√§hlen --</option>
        <option value="dawn">üåÖ Morgend√§mmerung</option>
        <option value="morning">‚òÄÔ∏è Morgen</option>
        <option value="noon">üåû Mittag</option>
        <option value="afternoon">üå§Ô∏è Nachmittag</option>
        <option value="sunset">üåá Sonnenuntergang</option>
        <option value="dusk">üåÜ Abendd√§mmerung</option>
        <option value="night">üåô Nacht</option>
        <option value="midnight">üåë Mitternacht</option>
      </select>
    </div>
    <div class="control-row">
      <label>Schatten-Qualit√§t</label>
      <select id="shadowQuality">
        <option value="1024">Niedrig</option>
        <option value="2048" selected>Mittel</option>
        <option value="4096">Hoch</option>
      </select>
    </div>
    <div class="control-row">
      <label>Schatten-Intensit√§t</label>
      <input type="range" id="shadowIntensity" min="0" max="100" value="40">
    </div>
    <div class="control-row">
      <label>Zeit animieren</label>
      <input type="checkbox" id="chkAnimateTime">
    </div>

    <h3>‚ö° Performance</h3>
    <div class="control-row">
      <label>Qualit√§tsstufe</label>
      <select id="qualityPreset">
        <option value="ultra">Ultra</option>
        <option value="high" selected>Hoch</option>
        <option value="medium">Mittel</option>
        <option value="low">Niedrig</option>
      </select>
    </div>
    <div class="control-row">
      <label>Auto-Anpassung</label>
      <input type="checkbox" id="chkAdaptive" checked>
    </div>
    <div class="control-row">
      <label>VRAM Limit (MB)</label>
      <input type="range" id="vramLimit" min="512" max="8192" value="2048" step="256">
    </div>

    <h3>üìç Navigation</h3>
    <button class="btn secondary" id="btnNYC">New York</button>
    <button class="btn secondary" id="btnParis">Paris</button>
    <button class="btn secondary" id="btnTokyo">Tokyo</button>
    <button class="btn secondary" id="btnDubai">Dubai</button>

    <h3>‚ÑπÔ∏è Info</h3>
    <p style="color: #888; font-size: 11px; line-height: 1.5;">
      <strong>Tastatur:</strong><br>
      C - First-Person an/aus<br>
      X - Beleuchtung an/aus<br>
      WASD - Bewegen<br>
      Q/E - Hoch/Runter<br>
      Shift - Schneller<br>
      ESC - FP-Modus beenden<br><br>
      <strong>üéÆ Controller:</strong><br>
      A - First-Person an/aus<br>
      X - Beleuchtung an/aus<br>
      L-Stick - Bewegen<br>
      R-Stick - Umsehen<br>
      Trigger - Hoch/Runter<br>
      B - Speed Boost
    </p>
  </div>

  <!-- Loading Overlay -->
  <div id="loadingBox" class="status-box">
    <div class="spinner"></div>
    <div id="loadingText">Lade 3D Tiles...</div>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill" style="width: 0%"></div>
    </div>
  </div>

  <!-- FPS Display -->
  <div id="fpsBox" class="status-box">
    <div class="fps-label">FPS</div>
    <div class="fps-value good" id="fpsValue">--</div>
    <div class="vram-info">
      VRAM: <span class="vram-value" id="vramUsed">0</span> MB
      <br>Limit: <span class="vram-limit" id="vramLimitDisplay">2048</span> MB
    </div>
  </div>

  <!-- Quality Indicator -->
  <div id="qualityBox" class="status-box">
    <span class="quality-label">Qualit√§t:</span>
    <span class="quality-value" id="qualityValue">HIGH</span>
  </div>

  <!-- Mobile Quick Actions -->
  <div id="quickActions">
    <button class="quick-btn fps-btn" id="quickFps" title="First-Person">üéÆ</button>
    <button class="quick-btn shadow-btn" id="quickShadow" title="Beleuchtung">üåÖ</button>
    <button class="quick-btn quality-btn" id="quickQuality" title="Qualit√§t">‚ö°</button>
  </div>

  <!-- Crosshair for First-Person -->
  <div id="crosshair"></div>

  <!-- Mode Indicator -->
  <div id="modeIndicator">First-Person Modus aktiv - ESC oder C zum Beenden</div>

  <script>
    // ============================================================
    // CONFIGURATION
    // ============================================================
    const CONFIG = {
      // Cesium Ion Access Token
      CESIUM_TOKEN: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJmNWFjNDYxZC0yN2U5LTQ0MGYtYWY1Ny1lN2VmNGJiNjVlYTQiLCJpZCI6MjYzNTkwLCJpYXQiOjE3NjE3MzIzOTh9.HsP4Aq5jS6OiRwUXc8uRv6nwbrTcx8ugaGSkLiTYhO8",
      
      // Google 3D Tiles Asset ID
      GOOGLE_TILES_ASSET_ID: 2275207,
      
      // Startposition (NYC Battery Park)
      START_LOCATION: {
        longitude: -74.0150,
        latitude: 40.7033,
        height: 350
      },
      
      // Performance Settings
      VRAM_LIMIT_MB: 2048,
      TARGET_FPS: 30,
      
      // Quality Presets
      QUALITY_PRESETS: {
        ultra: { sse: 4, vram: 4096, shadows: true },
        high: { sse: 8, vram: 2048, shadows: true },
        medium: { sse: 16, vram: 1024, shadows: false },
        low: { sse: 32, vram: 512, shadows: false }
      }
    };

    // ============================================================
    // UTILITIES
    // ============================================================
    const Utils = {
      isMobile() {
        return /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      },

      clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      },

      lerp(a, b, t) {
        return a + (b - a) * t;
      },

      formatNumber(num) {
        return Math.round(num).toLocaleString();
      }
    };

    // ============================================================
    // LOADING MANAGER
    // ============================================================
    class LoadingManager {
      constructor() {
        this.loadingBox = document.getElementById('loadingBox');
        this.loadingText = document.getElementById('loadingText');
        this.progressFill = document.getElementById('progressFill');
      }

      show(text = 'Laden...') {
        this.loadingBox.style.display = 'block';
        this.loadingText.textContent = text;
      }

      hide() {
        this.loadingBox.style.display = 'none';
      }

      setProgress(percent, text) {
        this.progressFill.style.width = `${percent}%`;
        if (text) this.loadingText.textContent = text;
      }
    }

    // ============================================================
    // FPS MONITOR
    // ============================================================
    class FPSMonitor {
      constructor() {
        this.fps = 0;
        this.frames = 0;
        this.lastTime = performance.now();
        this.fpsValue = document.getElementById('fpsValue');
        this.vramUsed = document.getElementById('vramUsed');
        this.vramLimitDisplay = document.getElementById('vramLimitDisplay');
      }

      update() {
        this.frames++;
        const now = performance.now();
        const delta = now - this.lastTime;

        if (delta >= 1000) {
          this.fps = Math.round((this.frames * 1000) / delta);
          this.frames = 0;
          this.lastTime = now;
          this.updateDisplay();
        }
      }

      updateDisplay() {
        this.fpsValue.textContent = this.fps;
        this.fpsValue.className = 'fps-value ' + 
          (this.fps >= 50 ? 'good' : this.fps >= 30 ? 'medium' : 'bad');
      }

      updateVRAM(used, limit) {
        this.vramUsed.textContent = Math.round(used);
        this.vramLimitDisplay.textContent = Math.round(limit);
      }

      getFPS() {
        return this.fps;
      }
    }

    // ============================================================
    // ADAPTIVE QUALITY
    // ============================================================
    class AdaptiveQuality {
      constructor(viewer, tileset, fpsMonitor) {
        this.viewer = viewer;
        this.tileset = tileset;
        this.fpsMonitor = fpsMonitor;
        this.enabled = true;
        this.currentPreset = 'high';
        this.qualityValue = document.getElementById('qualityValue');
        this.qualitySelect = document.getElementById('qualityPreset');
        this.checkInterval = null;
      }

      start() {
        this.checkInterval = setInterval(() => this.check(), 3000);
      }

      stop() {
        if (this.checkInterval) {
          clearInterval(this.checkInterval);
          this.checkInterval = null;
        }
      }

      check() {
        if (!this.enabled) return;

        const fps = this.fpsMonitor.getFPS();
        const presets = ['low', 'medium', 'high', 'ultra'];
        const currentIndex = presets.indexOf(this.currentPreset);

        if (fps < 25 && currentIndex > 0) {
          this.setPreset(presets[currentIndex - 1]);
        } else if (fps > 55 && currentIndex < presets.length - 1) {
          this.setPreset(presets[currentIndex + 1]);
        }
      }

      setPreset(presetName) {
        const preset = CONFIG.QUALITY_PRESETS[presetName];
        if (!preset) return;

        this.currentPreset = presetName;
        this.tileset.maximumScreenSpaceError = preset.sse;
        this.tileset.cacheBytes = preset.vram * 1024 * 1024;
        
        this.qualityValue.textContent = presetName.toUpperCase();
        this.qualitySelect.value = presetName;

        console.log(`Quality: ${presetName.toUpperCase()} (SSE: ${preset.sse})`);
      }

      setEnabled(enabled) {
        this.enabled = enabled;
        if (enabled) {
          this.start();
        } else {
          this.stop();
        }
      }
    }

    // ============================================================
    // INPUT SYSTEM (First-Person + Gamepad + Touch)
    // ============================================================
    const InputSystem = {
      state: {
        moveForward: false, moveBackward: false, moveLeft: false, moveRight: false,
        moveUp: false, moveDown: false, firstPersonMode: false,
        moveSpeed: 8.0, heading: 0, pitch: 0
      },
      gamepad: { index: -1, lastButtonA: false, lastButtonX: false },
      camera: null,
      canvas: null,
      controller: null,
      viewer: null,
      lightingController: null,
      adaptiveQuality: null,
      
      config: {
        baseMoveSpeed: 8.0,
        speedMultiplier: 4.0,
        mouseSensitivity: 0.005,
        gamepadMoveSpeed: 12.0,
        gamepadSensitivity: 0.05,
        gamepadDeadzone: 0.15,
        invertRightStickX: true,
        invertRightStickY: true
      },
      
      init(viewer, lightingController, adaptiveQuality) {
        this.viewer = viewer;
        this.camera = viewer.camera;
        this.canvas = viewer.scene.canvas;
        this.controller = viewer.scene.screenSpaceCameraController;
        this.lightingController = lightingController;
        this.adaptiveQuality = adaptiveQuality;
        
        this.state.heading = this.camera.heading;
        this.state.pitch = this.camera.pitch;
        
        document.addEventListener("keydown", (e) => this.onKeyDown(e));
        document.addEventListener("keyup", (e) => this.onKeyUp(e));
        document.addEventListener("mousemove", (e) => this.onMouseMove(e));
        document.addEventListener("pointerlockchange", () => this.onPointerLockChange());
        
        // Touch controls for mobile
        if (Utils.isMobile()) {
          this.initTouchControls();
        }
        
        this.setupGamepad();
        console.log("‚úÖ InputSystem initialized (Keyboard + Mouse + Gamepad + Touch)");
      },
      
      initTouchControls() {
        let lastTouchX = 0;
        let lastTouchY = 0;
        let isTouching = false;
        
        this.canvas.addEventListener("touchstart", (e) => {
          if (this.state.firstPersonMode && e.touches.length === 1) {
            isTouching = true;
            lastTouchX = e.touches[0].clientX;
            lastTouchY = e.touches[0].clientY;
          }
        }, { passive: true });
        
        this.canvas.addEventListener("touchmove", (e) => {
          if (this.state.firstPersonMode && isTouching && e.touches.length === 1) {
            const touch = e.touches[0];
            const deltaX = touch.clientX - lastTouchX;
            const deltaY = touch.clientY - lastTouchY;
            
            this.state.heading += deltaX * this.config.mouseSensitivity * 0.5;
            this.state.pitch -= deltaY * this.config.mouseSensitivity * 0.5;
            this.state.pitch = Utils.clamp(this.state.pitch, -Math.PI/2, Math.PI/2);
            
            this.camera.setView({
              orientation: {
                heading: this.state.heading,
                pitch: this.state.pitch,
                roll: 0
              }
            });
            
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
          }
        }, { passive: true });
        
        this.canvas.addEventListener("touchend", () => {
          isTouching = false;
        }, { passive: true });
        
        console.log("‚úÖ Touch controls initialized");
      },
      
      onKeyDown(e) {
        const k = e.key.toLowerCase();
        
        // Global shortcuts
        if (k === "c") { e.preventDefault(); this.toggleFirstPerson(); return; }
        if (k === "x") { e.preventDefault(); this.lightingController?.toggle(); return; }
        if (k === "escape" && this.state.firstPersonMode) { e.preventDefault(); this.toggleFirstPerson(); return; }
        
        if (!this.state.firstPersonMode) return;
        
        switch (k) {
          case "w": case "arrowup": e.preventDefault(); this.state.moveForward = true; break;
          case "s": case "arrowdown": e.preventDefault(); this.state.moveBackward = true; break;
          case "a": case "arrowleft": e.preventDefault(); this.state.moveLeft = true; break;
          case "d": case "arrowright": e.preventDefault(); this.state.moveRight = true; break;
          case "q": e.preventDefault(); this.state.moveUp = true; break;
          case "e": case " ": e.preventDefault(); this.state.moveDown = true; break;
        }
        if (e.shiftKey) this.state.moveSpeed = this.config.baseMoveSpeed * this.config.speedMultiplier;
      },
      
      onKeyUp(e) {
        const k = e.key.toLowerCase();
        switch (k) {
          case "w": case "arrowup": this.state.moveForward = false; break;
          case "s": case "arrowdown": this.state.moveBackward = false; break;
          case "a": case "arrowleft": this.state.moveLeft = false; break;
          case "d": case "arrowright": this.state.moveRight = false; break;
          case "q": this.state.moveUp = false; break;
          case "e": case " ": this.state.moveDown = false; break;
        }
        if (!e.shiftKey) this.state.moveSpeed = this.config.baseMoveSpeed;
      },
      
      onMouseMove(e) {
        if (!this.state.firstPersonMode || document.pointerLockElement !== this.canvas) return;
        this.state.heading += e.movementX * this.config.mouseSensitivity;
        this.state.pitch -= e.movementY * this.config.mouseSensitivity;
        this.state.pitch = Utils.clamp(this.state.pitch, -Math.PI/2, Math.PI/2);
        this.camera.setView({ orientation: { heading: this.state.heading, pitch: this.state.pitch, roll: 0 }});
      },
      
      onPointerLockChange() {
        if (!document.pointerLockElement && this.state.firstPersonMode && !Utils.isMobile()) {
          // Pointer lost - stay in FP mode but notify user
          console.log("‚ö†Ô∏è Pointer lock lost - click to re-engage");
        }
      },
      
      toggleFirstPerson() {
        this.state.firstPersonMode = !this.state.firstPersonMode;
        if (this.state.firstPersonMode) {
          this.setDefaultControls(false);
          this.state.heading = this.camera.heading;
          this.state.pitch = this.camera.pitch;
          if (!Utils.isMobile()) {
            try { this.canvas.requestPointerLock(); } catch(e) {}
          }
        } else {
          this.setDefaultControls(true);
          if (document.pointerLockElement === this.canvas) {
            try { document.exitPointerLock(); } catch(e) {}
          }
        }
        this.updateUI();
      },
      
      setDefaultControls(enabled) {
        this.controller.enableRotate = enabled;
        this.controller.enableTranslate = enabled;
        this.controller.enableZoom = enabled;
        this.controller.enableTilt = enabled;
        this.controller.enableLook = enabled;
      },
      
      updateUI() {
        const btn = document.getElementById('btnFirstPerson');
        const crosshair = document.getElementById('crosshair');
        const modeIndicator = document.getElementById('modeIndicator');
        const quickFps = document.getElementById('quickFps');
        
        if (this.state.firstPersonMode) {
          if (btn) {
            btn.textContent = 'üö∂ FP-Modus beenden (ESC)';
            btn.classList.add('danger');
          }
          if (crosshair) crosshair.style.display = 'block';
          if (modeIndicator) modeIndicator.style.display = 'block';
          if (quickFps) quickFps.classList.add('active');
        } else {
          if (btn) {
            btn.textContent = 'üéÆ First-Person Modus (C)';
            btn.classList.remove('danger');
          }
          if (crosshair) crosshair.style.display = 'none';
          if (modeIndicator) modeIndicator.style.display = 'none';
          if (quickFps) quickFps.classList.remove('active');
        }
      },
      
      // ==================== GAMEPAD ====================
      setupGamepad() {
        // Initial scan with delays
        [100, 500, 1000, 2000].forEach(d => setTimeout(() => this.scanGamepads(), d));
        // Continuous scan
        setInterval(() => this.scanGamepads(), 700);
        
        window.addEventListener("gamepadconnected", (e) => {
          console.log(`üéÆ Gamepad connected: ${e.gamepad.id}`);
          this.gamepad.index = e.gamepad.index;
          this.updateGamepadUI();
        });
        window.addEventListener("gamepaddisconnected", () => {
          console.log("üéÆ Gamepad disconnected");
          this.gamepad.index = -1;
          this.updateGamepadUI();
        });
      },
      
      scanGamepads() {
        const gps = navigator.getGamepads ? navigator.getGamepads() : [];
        let found = false;
        for (let i = 0; i < gps.length; i++) {
          if (gps[i]) {
            if (this.gamepad.index !== i) {
              this.gamepad.index = i;
              console.log(`üéÆ Found gamepad at index ${i}: ${gps[i].id}`);
            }
            found = true;
            break;
          }
        }
        if (!found && this.gamepad.index !== -1) {
          this.gamepad.index = -1;
        }
        this.updateGamepadUI();
      },
      
      updateGamepadUI() {
        const statusEl = document.getElementById('gamepadStatus');
        if (!statusEl) return;
        
        if (this.gamepad.index !== -1) {
          const gp = navigator.getGamepads()[this.gamepad.index];
          const name = gp ? gp.id.substring(0, 25) : "Controller";
          statusEl.innerHTML = `<span style="color:#34a853;">üéÆ ${name}</span>`;
          statusEl.style.background = "rgba(52, 168, 83, 0.2)";
        } else {
          statusEl.innerHTML = `<span style="color:#fbbc04;">üéÆ Kein Controller</span>
            <button id="detectGamepadBtn" style="float:right;padding:4px 8px;background:#4285f4;color:white;border:none;border-radius:4px;font-size:10px;cursor:pointer;">Suchen</button>`;
          statusEl.style.background = "rgba(251, 188, 4, 0.2)";
          
          const btn = document.getElementById('detectGamepadBtn');
          if (btn) {
            btn.onclick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              this.scanGamepads();
            };
          }
        }
      },
      
      processGamepad() {
        if (this.gamepad.index === -1) return;
        const gps = navigator.getGamepads();
        const gp = gps[this.gamepad.index];
        if (!gp) { this.gamepad.index = -1; return; }
        
        // A button - Toggle First-Person
        const aPressed = gp.buttons[0] && gp.buttons[0].pressed;
        if (aPressed && !this.gamepad.lastButtonA) this.toggleFirstPerson();
        this.gamepad.lastButtonA = aPressed;
        
        // X button - Toggle Lighting
        const xPressed = gp.buttons[2] && gp.buttons[2].pressed;
        if (xPressed && !this.gamepad.lastButtonX) this.lightingController?.toggle();
        this.gamepad.lastButtonX = xPressed;
        
        if (!this.state.firstPersonMode) return;
        
        // Left stick - Movement
        const leftX = this.applyDeadzone(gp.axes[0] || 0);
        const leftY = this.applyDeadzone(gp.axes[1] || 0);
        
        // Right stick - Look
        let rightX = this.applyDeadzone(gp.axes[2] || 0);
        let rightY = this.applyDeadzone(gp.axes[3] || 0);
        if (this.config.invertRightStickX) rightX = -rightX;
        if (this.config.invertRightStickY) rightY = -rightY;
        
        // Triggers - Up/Down
        let leftTrig = 0, rightTrig = 0;
        if (gp.buttons[6]) leftTrig = gp.buttons[6].value;
        if (gp.buttons[7]) rightTrig = gp.buttons[7].value;
        
        // B button - Speed boost
        const boost = (gp.buttons[1] && gp.buttons[1].pressed) ? this.config.speedMultiplier : 1.0;
        
        // Apply movement
        if (leftY !== 0) this.camera.moveForward(-leftY * this.config.gamepadMoveSpeed * boost);
        if (leftX !== 0) this.camera.moveRight(leftX * this.config.gamepadMoveSpeed * boost);
        if (rightTrig > 0.05) this.camera.moveUp(rightTrig * this.config.gamepadMoveSpeed * boost);
        if (leftTrig > 0.05) this.camera.moveDown(leftTrig * this.config.gamepadMoveSpeed * boost);
        
        // Apply look
        if (rightX !== 0 || rightY !== 0) {
          this.state.heading -= rightX * this.config.gamepadSensitivity;
          this.state.pitch -= rightY * this.config.gamepadSensitivity;
          this.state.pitch = Utils.clamp(this.state.pitch, -Math.PI/2, Math.PI/2);
          this.camera.setView({ orientation: { heading: this.state.heading, pitch: this.state.pitch, roll: 0 }});
        }
      },
      
      applyDeadzone(value) {
        return Math.abs(value) < this.config.gamepadDeadzone ? 0 : value;
      },
      
      update() {
        this.processGamepad();
        if (!this.state.firstPersonMode) return;
        
        if (this.state.moveForward) this.camera.moveForward(this.state.moveSpeed);
        if (this.state.moveBackward) this.camera.moveBackward(this.state.moveSpeed);
        if (this.state.moveLeft) this.camera.moveLeft(this.state.moveSpeed);
        if (this.state.moveRight) this.camera.moveRight(this.state.moveSpeed);
        if (this.state.moveUp) this.camera.moveUp(this.state.moveSpeed);
        if (this.state.moveDown) this.camera.moveDown(this.state.moveSpeed);
      },
      
      setMoveSpeed(speed) {
        this.config.baseMoveSpeed = speed;
        this.state.moveSpeed = speed;
      },
      
      setSensitivity(sensitivity) {
        this.config.mouseSensitivity = sensitivity / 10000;
      }
    };

    // ============================================================
    // LIGHTING CONTROLLER (Dynamic Sun Lighting for Google 3D Tiles)
    // ============================================================
    class LightingController {
      constructor(viewer, tileset) {
        this.viewer = viewer;
        this.tileset = tileset;
        this.enabled = false;
        this.ambientMode = 'realistic';
      }

      enable() {
        this.enabled = true;
        const scene = this.viewer.scene;
        const globe = scene.globe;

        // Enable globe lighting (sun-based)
        globe.enableLighting = true;
        globe.dynamicAtmosphereLighting = true;
        globe.dynamicAtmosphereLightingFromSun = true;

        // Enable shadows with anti-acne settings
        scene.shadowMap.enabled = true;
        scene.shadowMap.darkness = 0.4;
        scene.shadowMap.softShadows = true;
        scene.shadowMap.size = 2048;
        scene.shadowMap.normalOffset = true;
        scene.shadowMap.fadingEnabled = true;
        scene.shadowMap.maximumDistance = 10000.0;

        // Globe receives shadows
        globe.shadows = Cesium.ShadowMode.RECEIVE_ONLY;

        // Apply lighting to tileset
        this.applyToTileset('realistic');

        // Update UI
        document.getElementById('chkLighting').checked = true;
        document.getElementById('quickShadow').classList.add('active');

        console.log('üåÖ Dynamic lighting ENABLED');
      }

      disable() {
        this.enabled = false;
        const scene = this.viewer.scene;
        const globe = scene.globe;

        // Disable globe lighting
        globe.enableLighting = false;
        globe.dynamicAtmosphereLighting = false;
        globe.dynamicAtmosphereLightingFromSun = false;

        // Disable shadows
        scene.shadowMap.enabled = false;
        globe.shadows = Cesium.ShadowMode.DISABLED;

        // Reset tileset to bright
        this.applyToTileset('bright');

        // Update UI
        document.getElementById('chkLighting').checked = false;
        document.getElementById('quickShadow').classList.remove('active');

        console.log('üåë Dynamic lighting DISABLED');
      }

      toggle() {
        if (this.enabled) {
          this.disable();
        } else {
          this.enable();
        }
      }

      setEnabled(enabled) {
        if (enabled) {
          this.enable();
        } else {
          this.disable();
        }
      }

      applyToTileset(mode) {
        if (!this.tileset) return;

        try {
          if (!this.tileset.imageBasedLighting) return;

          switch(mode) {
            case 'realistic':
              // Pure sun lighting - dramatic day/night
              this.tileset.imageBasedLighting.enabled = false;
              this.tileset.shadows = Cesium.ShadowMode.ENABLED;
              break;

            case 'soft':
              // Subtle ambient with low luminance
              this.tileset.imageBasedLighting.enabled = true;
              this.tileset.imageBasedLighting.luminanceAtZenith = 0.02;
              this.tileset.shadows = Cesium.ShadowMode.ENABLED;
              break;

            case 'balanced':
              // Balanced ambient
              this.tileset.imageBasedLighting.enabled = true;
              this.tileset.imageBasedLighting.luminanceAtZenith = 0.1;
              this.tileset.shadows = Cesium.ShadowMode.ENABLED;
              break;

            case 'bright':
              // Full ambient - no day/night effect
              this.tileset.imageBasedLighting.enabled = true;
              this.tileset.imageBasedLighting.luminanceAtZenith = 0.8;
              this.tileset.shadows = Cesium.ShadowMode.DISABLED;
              break;
          }

          this.ambientMode = mode;
          console.log(`üí° Applied ${mode} lighting mode`);

        } catch (error) {
          // Google 3D Tiles have read-only IBL but still respond to globe lighting
          console.log('‚ÑπÔ∏è Using automatic sun lighting for Google 3D Tiles');
        }
      }

      setAmbientMode(mode) {
        this.applyToTileset(mode);
        document.getElementById('ambientMode').value = mode;
      }

      setTime(hour) {
        // Create date with specific hour (UTC)
        const now = new Date();
        now.setUTCHours(Math.floor(hour), (hour % 1) * 60, 0, 0);
        this.viewer.clock.currentTime = Cesium.JulianDate.fromDate(now);
        this.viewer.clock.shouldAnimate = false;
      }

      setPresetTime(preset) {
        const presets = {
          'dawn': 6,
          'morning': 9,
          'noon': 12,
          'afternoon': 15,
          'sunset': 18,
          'dusk': 19.5,
          'night': 23,
          'midnight': 0
        };

        if (presets[preset] !== undefined) {
          this.setTime(presets[preset]);
          console.log(`‚è∞ Time set to ${preset} (${presets[preset]}:00)`);
        }
      }

      setShadowQuality(size) {
        this.viewer.scene.shadowMap.size = parseInt(size);
      }

      setShadowIntensity(darkness) {
        this.viewer.scene.shadowMap.darkness = Math.max(0, Math.min(1, darkness));
      }

      animateTime(enable, speed = 100) {
        if (enable) {
          this.viewer.clock.shouldAnimate = true;
          this.viewer.clock.multiplier = speed;
          console.log(`‚è© Time animation: ${speed}x`);
        } else {
          this.viewer.clock.shouldAnimate = false;
        }
      }
    }

    // ============================================================
    // UI CONTROLLER
    // ============================================================
    class UIController {
      constructor() {
        this.panel = document.getElementById('panel');
        this.menuToggle = document.getElementById('menuToggle');
        this.panelClose = document.getElementById('panelClose');
        this.quickActions = document.getElementById('quickActions');
        this.isPanelOpen = false;

        this.setupEventListeners();
      }

      setupEventListeners() {
        this.menuToggle.addEventListener('click', () => this.togglePanel());
        this.panelClose.addEventListener('click', () => this.closePanel());

        // Close panel when clicking outside
        document.addEventListener('click', (e) => {
          if (this.isPanelOpen && 
              !this.panel.contains(e.target) && 
              !this.menuToggle.contains(e.target)) {
            this.closePanel();
          }
        });
      }

      togglePanel() {
        this.isPanelOpen = !this.isPanelOpen;
        this.panel.classList.toggle('open', this.isPanelOpen);
        this.menuToggle.textContent = this.isPanelOpen ? '‚úï' : '‚ò∞';
      }

      closePanel() {
        this.isPanelOpen = false;
        this.panel.classList.remove('open');
        this.menuToggle.textContent = '‚ò∞';
      }

      openPanel() {
        this.isPanelOpen = true;
        this.panel.classList.add('open');
        this.menuToggle.textContent = '‚úï';
      }
    }

    // ============================================================
    // MAIN APPLICATION
    // ============================================================
    class App {
      constructor() {
        this.viewer = null;
        this.tileset = null;
        this.loadingManager = new LoadingManager();
        this.fpsMonitor = new FPSMonitor();
        this.uiController = new UIController();
        this.fpController = null;
        this.shadowController = null;
        this.adaptiveQuality = null;
        this.lastTime = performance.now();
      }

      async init() {
        try {
          this.loadingManager.show('Initialisiere Cesium...');
          this.loadingManager.setProgress(10);

          // Set Cesium Ion Token
          Cesium.Ion.defaultAccessToken = CONFIG.CESIUM_TOKEN;

          // Create Viewer with standard widgets
          this.viewer = new Cesium.Viewer('cesiumContainer', {
            timeline: true,
            animation: true,
            baseLayerPicker: true,
            geocoder: true,
            homeButton: true,
            sceneModePicker: true,
            navigationHelpButton: true,
            fullscreenButton: true,
            vrButton: false,
            infoBox: true,
            selectionIndicator: true,
            requestRenderMode: false,
            maximumRenderTimeChange: Infinity
          });

          // Configure scene with proper sky rendering
          const scene = this.viewer.scene;
          scene.globe.show = false;
          scene.skyAtmosphere.show = true;
          scene.skyBox.show = true;
          scene.sun.show = true;
          scene.moon.show = true;
          scene.fog.enabled = true;
          scene.fog.density = 0.0002;

          this.loadingManager.setProgress(30, 'Lade Google 3D Tiles...');

          // Load Google 3D Tiles
          this.tileset = await Cesium.Cesium3DTileset.fromIonAssetId(CONFIG.GOOGLE_TILES_ASSET_ID, {
            maximumScreenSpaceError: 8,
            cacheBytes: CONFIG.VRAM_LIMIT_MB * 1024 * 1024,
            maximumCacheOverflowBytes: 512 * 1024 * 1024,
            preloadWhenHidden: true,
            skipLevelOfDetail: true,
            immediatelyLoadDesiredLevelOfDetail: false
          });

          this.viewer.scene.primitives.add(this.tileset);

          this.loadingManager.setProgress(70, 'Initialisiere Controller...');

          // Initialize controllers
          this.lightingController = new LightingController(this.viewer, this.tileset);
          this.adaptiveQuality = new AdaptiveQuality(this.viewer, this.tileset, this.fpsMonitor);
          
          // Initialize InputSystem (replaces FirstPersonController)
          InputSystem.init(this.viewer, this.lightingController, this.adaptiveQuality);

          // Fly to start location
          this.viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(
              CONFIG.START_LOCATION.longitude,
              CONFIG.START_LOCATION.latitude,
              CONFIG.START_LOCATION.height
            ),
            orientation: {
              heading: Cesium.Math.toRadians(0),
              pitch: Cesium.Math.toRadians(-25),
              roll: 0
            },
            duration: 0
          });

          this.loadingManager.setProgress(90, 'Verbinde UI...');

          // Setup UI connections
          this.setupUI();

          // Start render loop
          this.viewer.scene.postRender.addEventListener(() => this.update());

          // Start adaptive quality
          this.adaptiveQuality.start();

          this.loadingManager.setProgress(100, 'Fertig!');
          
          setTimeout(() => {
            this.loadingManager.hide();
          }, 500);

          console.log('‚úÖ 3D Viewer initialized successfully');

        } catch (error) {
          console.error('‚ùå Initialization error:', error);
          this.loadingManager.setProgress(0, `Fehler: ${error.message}`);
        }
      }

      setupUI() {
        // First-Person Button
        document.getElementById('btnFirstPerson').addEventListener('click', () => {
          InputSystem.toggleFirstPerson();
        });

        // Move Speed
        document.getElementById('moveSpeed').addEventListener('input', (e) => {
          InputSystem.setMoveSpeed(parseInt(e.target.value));
        });

        // Mouse Sensitivity
        document.getElementById('mouseSensitivity').addEventListener('input', (e) => {
          InputSystem.setSensitivity(parseInt(e.target.value));
        });

        // Lighting Controls
        document.getElementById('chkLighting').addEventListener('change', (e) => {
          this.lightingController.setEnabled(e.target.checked);
        });

        // Ambient Mode
        document.getElementById('ambientMode').addEventListener('change', (e) => {
          this.lightingController.setAmbientMode(e.target.value);
        });

        // Time of Day
        document.getElementById('timeOfDay').addEventListener('input', (e) => {
          this.lightingController.setTime(parseFloat(e.target.value));
        });

        // Time Preset
        document.getElementById('timePreset').addEventListener('change', (e) => {
          if (e.target.value) {
            this.lightingController.setPresetTime(e.target.value);
            // Update time slider to match
            const presetHours = {
              'dawn': 6, 'morning': 9, 'noon': 12, 'afternoon': 15,
              'sunset': 18, 'dusk': 19.5, 'night': 23, 'midnight': 0
            };
            document.getElementById('timeOfDay').value = presetHours[e.target.value];
          }
        });

        // Shadow Quality
        document.getElementById('shadowQuality').addEventListener('change', (e) => {
          this.lightingController.setShadowQuality(e.target.value);
        });

        // Shadow Intensity
        document.getElementById('shadowIntensity').addEventListener('input', (e) => {
          this.lightingController.setShadowIntensity(parseInt(e.target.value) / 100);
        });

        // Animate Time
        document.getElementById('chkAnimateTime').addEventListener('change', (e) => {
          this.lightingController.animateTime(e.target.checked, 500);
        });

        // Quality Preset
        document.getElementById('qualityPreset').addEventListener('change', (e) => {
          this.adaptiveQuality.setPreset(e.target.value);
        });

        // Adaptive Quality Toggle
        document.getElementById('chkAdaptive').addEventListener('change', (e) => {
          this.adaptiveQuality.setEnabled(e.target.checked);
        });

        // VRAM Limit
        document.getElementById('vramLimit').addEventListener('input', (e) => {
          const limit = parseInt(e.target.value);
          this.tileset.cacheBytes = limit * 1024 * 1024;
          this.fpsMonitor.updateVRAM(0, limit);
        });

        // Navigation buttons
        const locations = {
          btnNYC: { lon: -74.0060, lat: 40.7128, height: 400, name: 'New York' },
          btnParis: { lon: 2.2945, lat: 48.8584, height: 300, name: 'Paris' },
          btnTokyo: { lon: 139.6917, lat: 35.6895, height: 400, name: 'Tokyo' },
          btnDubai: { lon: 55.2744, lat: 25.1972, height: 500, name: 'Dubai' }
        };

        Object.entries(locations).forEach(([btnId, loc]) => {
          document.getElementById(btnId).addEventListener('click', () => {
            this.flyTo(loc.lon, loc.lat, loc.height);
          });
        });

        // Quick Actions (Mobile)
        document.getElementById('quickFps').addEventListener('click', () => {
          InputSystem.toggleFirstPerson();
        });

        document.getElementById('quickShadow').addEventListener('click', () => {
          this.lightingController.toggle();
        });

        document.getElementById('quickQuality').addEventListener('click', () => {
          const presets = ['low', 'medium', 'high', 'ultra'];
          const currentIndex = presets.indexOf(this.adaptiveQuality.currentPreset);
          const nextIndex = (currentIndex + 1) % presets.length;
          this.adaptiveQuality.setPreset(presets[nextIndex]);
        });

        // Initialize VRAM display
        this.fpsMonitor.updateVRAM(0, CONFIG.VRAM_LIMIT_MB);
      }

      flyTo(lon, lat, height) {
        this.viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(lon, lat, height),
          orientation: {
            heading: 0,
            pitch: Cesium.Math.toRadians(-25),
            roll: 0
          },
          duration: 2
        });
      }

      update() {
        const now = performance.now();
        const deltaTime = (now - this.lastTime) / 1000;
        this.lastTime = now;

        // Update FPS
        this.fpsMonitor.update();

        // Update InputSystem (First-Person + Gamepad)
        InputSystem.update();

        // Update VRAM display
        if (this.tileset && this.tileset.statistics) {
          const stats = this.tileset.statistics;
          const usedBytes = (stats.geometryByteLength || 0) + (stats.texturesByteLength || 0);
          const usedMB = usedBytes / (1024 * 1024);
          this.fpsMonitor.updateVRAM(usedMB, this.tileset.cacheBytes / (1024 * 1024));
        }
      }
    }

    // ============================================================
    // START APPLICATION
    // ============================================================
    const app = new App();
    app.init();
  </script>
</body>
</html>
